# 基于易灵思Ti60F225的内窥镜ISP设计**摘要**

本设计针对内窥镜成像场景中弱光、高噪声、雾气干扰、色彩失真等问题，基于 FPGA 实现高实时性、低资源消耗的 ISP（图像信号处理）系统。系统集成 Bayer 域降噪（BNR）、坏点校正（DPC）、自适应对比度增强（CLAHE）、二维降噪（2DNR）、锐化（SHARPEN）、自动曝光（AE）、自动白平衡（AWB）、色彩校正（CCM）及去雾等核心模块，支持 1280×720@30fps 分辨率处理，延迟低于 10ms，可通过串口实时调整降噪、去雾等参数，有效提升内窥镜图像的清晰度、对比度与色彩还原度，为医疗诊断提供精准的视觉支持。

# **第一部分 作品概述**

## **1.1功能与特性**

系统面向医疗内窥镜场景，核心功能包括多维度噪声抑制（针对弱光环境下的传感器噪声）、病灶细节增强、雾气与分泌物干扰去除、自动光照适配、色彩精准还原。采用流水线架构设计，实现图像实时处理，无卡顿延迟；支持五档Bayer降噪强度、连续可调去雾强度、分档二维降噪强度、连续可调二维降噪强度以及连续可调锐化强度，适配胃肠镜、腹腔镜等不同内窥镜设备的成像需求；硬件层面通过移位替代乘除法、伪双端口 RAM 乒乓操作等优化，资源消耗低，适配小型化内窥镜设备的硬件约束。

## **1.2应用领域**

主要应用于医疗内窥镜诊断设备，包括胃肠镜、腹腔镜、支气管镜等侵入式医疗成像设备，可提升体内弱光、复杂环境下的图像质量，帮助医生清晰识别病灶边界、血管分布等关键信息。同时可扩展至工业内窥镜检测场景（如管道、机械内部检测），解决工业环境中的低照度、粉尘干扰成像问题。

## **1.3主要技术特点**

1.针对性优化：针对内窥镜弱光环境，优化 AE 算法的 ROI 区域选择，优先保障病灶区域曝光准确；

2.低资源高效实现：CLAHE 模块采用分块并行处理 + 旁路逻辑解决 RAM 冲突，2DNR 用移位模拟高斯权重，零 DSP 消耗；

3.灵活可调：所有核心参数（降噪、去雾、锐化强度）支持串口实时配置，无需重启系统；

4.全链路保真：从 Bayer RAW 数据到 YUV 输出的全流程处理，保留图像细节的同时抑制噪声与伪影。

## **1.4主要性能指标**

表1.4 主要性能指标表

|     |     |
| --- | --- |
| 指标名称 | 参数  |
| 支持分辨率 | 1280×720 |
| 处理帧率 | ≥30fps |
| 单周期像素吞吐量 | 1   |
| 图像处理延迟 | ~1.02μs |
| Bayer降噪强度 | 5档可调 |
| 去雾强度 | 连续可调 |
| 二维降噪强度 | 连续可调 |
| 锐化强度 | 连续可调 |
| 数字增益 | 100级可调 |
| 白平衡增益 | 12 位 R/B 通道独立调整 |

## **1.5主要创新点**

1\. 内窥镜专用 AE 算法：通过偏度分析进行曝光判断，结合中心照度校准，有效适应体内弱光和高反射环境；

2\. 低延迟去雾优化：采用三级排序树架构执行暗通道计算，处理延迟降低30%，完美契合实时诊断需求；

3\. 自适应限制对比度的直方图均衡化算法：实现画面不同区域的自适应增强，运用分块并行处理机制和旁路逻辑优化 RAM 冲突，高效抑制局部过曝，显著提升细节对比度，特别保留病灶边缘及弱光区域的纹理，避免传统方法引发的噪声放大问题，确保图像清晰度和诊断可靠性；

4\. 多模块协同优化：BNR 与 2DNR 级联设计，先抑制 Bayer 域噪声，再优化 Y 通道细节，实现降噪与锐度的理想平衡；

5.CCM色彩优化：对RGB通道显示进行校正，使显示画面更贴近真实场景。

# **第二部分 系统组成及功能说明**

2

## **2.1整体介绍**

图2.1 整体图

这套内窥镜图像采集与处理系统以 “采集 - 处理 - 控制 - 显示” 为核心流程，内窥镜通过 vsync 场同步信号、href 行同步信号及 8 位 raw_data 原始图像数据，将医疗场景图像传输至 TI60F225 图像信号处理器，后者经 RAW 域、RGB 域、YUV 域的多阶段优化处理提升画质，STM32 作为上位机通过UART串口控制ISP，同时借助LVGL GUI界面进行便捷的人机交互，最终由显示器呈现清晰准确的图像，为医疗诊断提供支持。

## **2.2硬件系统介绍**

### **2.2.1 硬件整体介绍**

图2.2.1 硬件整体介绍

STM32作为上位机进行控制，A2020内窥模组实现图像采集，ISP部署在TI60F225开发板上。

## **2.3软件系统介绍**

### **2.3.1 软件整体介绍**

本工程主体架构如下，其中输入部分、显示输出部分来自奥唯思提供的基础工程，本项目的工作在于ISP设计部分和UART指令调节部分。UART部分便于上位机控制ISP部分，进行算法的开关、算法强度等参数的手动设置，提高ISP对不同场景的可适配性。ISP部分设计分RAW、RGB、YUV三域进行，全工程架构图和ISP部分流水线结构图如下：

图2.3.1(1) 工程整体架构图

图2.3.1(2) ISP部分流水线结构图

### **2.3.2 软件各模块介绍**

#### 2.3.2.1 串口模块

UART控制系统是本FPGA图像处理平台的核心控制接口，负责接收来自外部设备（PC或STM32）的控制指令，实时调整ISP（Image Signal Processing）流水线中各个图像处理模块的参数。

其中关键模块为指令解析与控制模块 (uart_control），该部分采用统一的多字节指令格式，使用状态机进行指令译码，产生ISP模块的开关，或者参数调整信号。

指令采用以下格式设计：

单字节指令：\[指令码\]（如系统复位）

双字节指令：\[指令码\] \[参数\]（最常用，如开关控制、8位参数）

三字节指令：\[指令码\] \[高字节\] \[低字节\]（如16位参数）

图2.3.2.1 UART模块结构图

#### 2.3.2.2 RAW域处理模块

##### 2.3.2.2.1 BNR (Bayer Noise Reduction) 模块

图2.3.2.2.1 BNR模块流程图

BNR (Bayer Noise Reduction) 是一个Bayer域降噪模块，工作在ISP流水线的早期阶段，直接对相机传感器输出的RAW图像数据进行降噪处理。由于Raw域数据是R/G/B通道独立的，所以BNR模块需要通过根据像素类型选择不同的卷积核，只对同色像素进行加权平均，避免色彩混叠。进行卷积运算时，需要先判断当前窗口中心像素所在通道，选择不同卷积核。

对于中心像素所在通道的判断，采用行数和列数的奇偶性判断，同时可适配不同的Bayer像素排列格式。

由于降噪会导致丢失图像细节，为了适配不同图形处理需求，便于用户自行调整，我们设置了5档降噪强度，可通过串口指令实时调整，表格如下。

表2.3.2.2.1 BNR强度对照表

BNR针对Bayer阵列的特殊排列设计了两套独立的卷积核，

由于R/B像素在Bayer阵列中呈对角分布，因此相邻像素在对角线方向，因此R/B通道的五组卷积核为：

图2.3.2.2.1(1) BNR模块R/B通道卷积核

由于G像素在Bayer阵列中呈十字分布，因此相邻像素在垂直和水平方向，因此Gr/Gb通道的五组卷积核为：

图2.3.2.2.1(2) BNR模块Gr/Gb通道卷积核

由于使用5×5卷积核，生成卷积窗口需要5行数据，所以使用移位寄存器缓存四行数据，与当前行协同，移位生成5×5卷积窗口。

为提高计算效率，优化资源利用，卷积和最后的归一化涉及的乘除法均使用移位实现。

##### 2.3.2.2.2 DPC (Defective Pixel Correction) 模块

图2.3.2.2.2 DPC模块流程图

DPC模块采用基于邻域差值的坏点检测算法，核心思想是：坏点通常表现为亮点（hot pixel）或暗点（dead pixel），与周围像素的差值具有单向性（全部为正或全部为负）且幅度较大。流程如下：

1.提取同色通道邻域，在5×5 Bayer窗口中，提取与中心像素相同颜色的8个邻域像素；

2.计算中心像素与周围8个像素的差值：diff\[i\] = center - neighbor\[i\]；

3.检查8个差值的符号位是否全部相同，全为正（符号位=0）或全为负（符号位=1）时，认为可能是坏点；

4.计算每个差值的绝对值，若8个绝对值均大于阈值，则确认为坏点；

5.若为坏点，则使用中值滤波取代坏点。

对于中值滤波的视线，这里采用高效的3级中值滤波算法，避免直接排序9个像素。流程如下：

1. 将9个像素分为3组，每组3个像素，每组内部排序，得到最小值、中值、最大值

组1: \[p1, p2, p3\] ⟹ \[min1, med1, max1\]

组2: \[p4, p5, p6\] ⟹ \[min2, med2, max2\]

组3: \[p7, p8, p9\] ⟹ \[min3, med3, max3\]

2.分组间排序

对3组的最小值求最大值：max_of_min = max(min1, min2, min3)

对3组的中值求中值：med_of_med = med(med1, med2, med3)

对3组的最大值求最小值：min_of_max = min(max1, max2, max3)

3.对上述3个值求中值，得到最终中值。

##### 2.3.2.2.3 AWB自动白平衡模块

###### 2.3.2.2.3.1 基本原理

图2.3.2.2.3.1 AWB模块流程图

isp_awb模块基于灰度世界算法进行设计，专门针对Bayer格式原始图像开展色彩校准工作。

其中，灰度世界算法是一种经典且高效的白平衡算法，核心假设是自然场景中所有像素的红、绿、蓝三通道平均亮度趋于一致（即 “灰度”），通过这一假设修正 Bayer 格式原始图像的色彩偏差。其核心逻辑是先统计图像中红、绿、蓝三个通道的像素平均灰度值，再以三个通道的平均灰度或预设的标准灰度（如 128）为基准，计算各通道的增益系数，最后将每个像素的对应通道值乘以相应增益，使三通道亮度趋于均衡，从而消除环境光（如暖光、冷光）导致的偏色，还原图像真实色彩。

isp_awb模块核心工作流程围绕图像有效区域提取、高质量数据筛选、通道统计分析及增益计算展开：首先通过裁剪参数校准与ROI（感兴趣区域）裁剪操作过滤图像无效区域，保留有效像素；接着构建2×2像素窗口并对窗口内像素进行亮度筛选，排除过曝与欠曝数据以保证后续处理精度；

其中，我们采取移位寄存器实现行缓冲，构建 Bayer 图像的 2×2 像素窗口，并输出窗口数据及像素位置标识。同时，筛选出亮度在合理范围内的 2×2 窗口，排除过曝或欠曝像素的干扰，输出 “good” 信号标识有效窗口，为后续处理提供高质量的窗口数据。

随后按Bayer模式分离R/G/B三通道，统计各通道有效像素总和；最后计算绿色均值与R/B通道总和的比值以得到白平衡增益，经指定帧数累积稳定后输出12位R/B增益，从而实现不同光照环境下图像白平衡的自动校准，还原真实色彩。

###### 2.3.2.2.3.2 裁剪模块（isp_crop_awb_ae）

对输入的 Bayer 原始图像执行有效区域裁剪，过滤无效区域像素。根据校准后的裁剪参数（awb_crop_left/right/top/bottom），在 href 有效期间判断当前像素是否在 ROI 内，输出裁剪后的 raw 数据与同步信号（href/vsync）。

###### 2.3.2.2.3.3 通道统计与增益计算模块

根据 Bayer 模式分离 R/G/B 通道，累加各通道有效像素总和，计算绿色均值及 R/B 总和。在帧消隐期启动除法器计算 R/B 白平衡增益，对 sumr/sumb 为 0 的情况做零保护，累积指定帧数后锁存并输出 12 位 R/B 增益，同时置位信号标识增益稳定。

该模块可由如下状态机来展示：

图2.3.2.2.3.3 AWB模块状态机流程图

该状态机共包含五个状态：初始状态为S_IDLE，在此等待帧同步信号并采样欠曝和过曝阈值、帧数等输入参数。当 vsync 上升沿到来时，进入S_STATISTICS状态，执行裁剪、2x2 窗口捕获、窗口筛选及 R/G/B 通道累加统计操作。待 vsync 下降沿触发：进入S_CALCULATES状态，启动 shift_div 除法器计算 R/B 增益，等待除法完成信号。当除法器均完成（r_done&b_done）：进入S_OUTPUT状态，锁存 R/B 增益值、帧计数器加 1，若计数达到设定帧数则置位就绪信号（high）。随后进入S_DONE状态：增益输出完成后保持增益值，等待下一帧同步信号触发新周期。此外，在任意状态下，若 rst_n=0 则会回到初始状态S_IDLE。

#### 2.3.2.3 RGB域处理模块

##### 2.3.2.3.1 AE自动曝光模块

###### 2.3.2.3.1.1 基本原理

图2.3.2.3.1.1 AE模块流程图

isp_ae模块是用于自动曝光（Auto Exposure）的硬件模块，模块首先对输入图像按指定区域裁剪，将 RGB 数据转换为灰度值，通过计算灰度与中心亮度的差值，进一步计算像素差异的平方和、立方和，结合裁剪窗口尺寸，利用除法和平方根运算求解偏斜度。根据偏斜度与阈值的比较结果，判定画面曝光状态（欠曝、过曝或正常），输出曝光响应ae_response、实际偏斜度ae_result_skewness等信号，实现对画面亮度的自动调节；同时提供目标亮度和偏斜度阈值的外部调节，便于模块功能的验证与性能分析，确保在不同光照场景下都能输出曝光准确的图像。

本设计的isp_ae模块基于像素亮度的偏度（skewness）分析实现曝光判断，支持自定义感兴趣区域（ROI）裁剪、128 级数字增益调整。模块通过接收 RGB 图像数据、中心照度、偏度阈值及裁剪窗口参数，经图像预处理、亮度统计、偏度计算等流程，输出曝光状态响应、计算得到的偏度值及数字增益索引，为后续图像增强提供精准的曝光控制依据。

###### 2.3.2.3.1.2 ROI 裁剪模块（isp_crop_awb_ae）

对 RGB 三通道图像分别执行对有效区域裁剪，过滤无效区域像素，仅保留目标区域数据。在 href 有效期间，根据采样后的裁剪参数判断当前像素是否在 ROI 内，输出裁剪后的通道数据与同步信号。

###### 2.3.2.3.1.3 核心运算模块

累加亮度偏差值的平方和与立方和，同步计算裁剪区域的有效像素总数。包含除法器（shift_div）与平方根 FSM，完成平方和均值、立方和均值及偏度的计算。

我们绘制了数据流示意图来总结概括运算的核心逻辑。

图2.3.2.3.1.3 AE模块数据流示意图

1.  首先输入数据 rgb，计算得到灰度 grey，将其与目标亮度相减得到差值 avg_pixel，进而计算出实际偏斜度 ae_skewness；
2.  将该偏斜度与偏斜度阈值 skewness 比较，判断出曝光状态 flag（欠曝、过曝、正常）；
3.  根据曝光状态确定增益值，调整画面亮度，而画面亮度又会影响数据 rgb 的输入，形成一个闭环的自动曝光调节过程。

###### 2.3.2.3.1.4 曝光判断逻辑

曝光状态的判断核心基于图像灰度值的偏度分析，偏度反映亮度分布的不对称程度：当偏度为正且大于设定阈值时，图像亮度分布右偏，判定为过曝；当偏度为负且绝对值大于设定阈值时，图像亮度分布左偏，判定为欠曝；当偏度在阈值范围内时，判定为正常曝光。

结合中心照度参数对灰度值进行校准，进一步提升曝光判断的准确性，确保在不同环境光线下的稳定表现。

##### 2.3.2.3.2 颜色校正（CCM）模块

###### 2.3.2.3.2.1 基本原理

图2.3.2.3.2.1 CCM模块流程图

isp_ccm模块是图像处理系统（ISP）中实现色彩校正的核心硬件模块，其核心功能是通过 3x3 色彩校正矩阵（CCM）对输入图像的 RGB 色彩进行精准映射与校准，以修正设备原生色彩偏差，使输出色彩符合目标标准色彩空间。模块接收配置好的 9 个矩阵系数（m_rr~m_bb，采用 S8.8 定点数格式）、输入 RGB 图像数据（in_r、in_g、in_b）及帧同步信号（in_href、in_vsync）。

工作流程上，模块先对输入的矩阵系数和 RGB 像素数据进行寄存器同步，再按色彩校正的矩阵运算规则，将每个通道的像素值与对应矩阵系数逐一相乘，随后对各通道的乘积结果进行累加求和，并通过右移 8 位完成定点数归一化处理，最后通过裁剪逻辑将结果限制在有效像素范围（避免负数值或溢出），同时对帧同步信号进行延迟对齐以匹配色彩运算的时序，最终输出校正后的 RGB 图像数据（out_r、out_g、out_b）及同步信号。

###### 2.3.2.3.2.2 矩阵参数

缓存色彩校正矩阵参数与输入 RGB 像素，为后续乘法运算提供稳定数据。将 16 位带符号矩阵参数（m_rr/m_rg/m_rb 等，S8.8 格式）与 8 位 RGB 输入像素（in_r/in_g/in_b）分别寄存，像素数据扩展为 9 位无符号格式（in_r_1/in_g_1/in_b_1）以避免运算溢出。

矩阵参数的确定过程是这样的：

ccm通过一个 3x3矩阵 对RGB通道的增益和交叉比例进行调整，校正传感器对不同波长光的响应差异。对角线元素（如 C11、C22、C33：控制各通道的增益比例。非对角线元素：补偿通道间的串扰（如红光泄漏到绿通道）。

我们关闭了其他所有ISP模块后使用内窥模组拍摄色卡的24个色块，用python脚本测量出显示画面中色卡的RGB值作为上式中的RGB，再查出色卡标准的RGB值作为R’G’B’，代入计算矩阵系数。经取样计算后得出系数如下：

图2.3.2.3.2.2 矩阵系数

###### 2.3.2.3.2.2 矩阵乘法与累加模块

执行 RGB 像素与校正矩阵的乘法运算，并累加各通道结果。按矩阵运算规则，计算 9 个乘积项（如 data_rr = m_rr_i × in_r_1），再分别累加得到 R/G/B 通道的校正结果（data_r = data_rr + data_rg + data_rb 等），通过右移 8 位（除以 256）完成 S8.8 格式的归一化。

##### 2.3.2.3.3伽马矫正（GAMMA）模块

###### 2.3.2.3.3.1基本原理

图2.3.2.3.3.1 GAMMA模块流程图

gamma 矫正模块通过三通道独立的真双端口 RAM 查找表（LUT），对 RGB 三色分量分别执行 gamma 矫正处理。模块核心采用full_dp_ram_init双端口 RAM IP 核，每个颜色通道对应一个独立 RAM，支持通过初始化文件加载自定义 gamma 参数，或默认使用 gamma 2.2 标准 sRGB 矫正曲线；同时提供动态配置接口，可实时更新各通道 LUT 数据，兼顾灵活性与通用性。工作时，模块同步接收 RGB 图像数据及行 / 场同步信号，在像素时钟驱动下通过 RAM 端口 B 完成矫正数据的并行查找，之后缓冲矫正结果并对齐同步信号，最终输出矫正后的 RGB 图像数据，如此循环处理后续接收的 RGB 图像数据与同步信号。

###### 2.3.2.3.3.2 full_dp_ram_initmok（双端口 RAM LUT 核心）

full_dp_ram_init 是 ISP Gamma 矫正模块的核心存储与查找单元，支持双端口独立读写与 gamma 曲线预配置，是实现 RGB 三通道并行矫正的关键组件。它作为 gamma 曲线的存储载体，将输入图像数据（RGB 分量）作为地址，通过查表输出矫正后的数据，完成 “地址→数据” 的实时映射。

图2.3.2.3.3.2 查找表LUT部分代码

代码通过 case 语句将 8 位输入索引（对应图像 RGB 分量的原始值）映射到矫正后的 8 位输出值。

###### 2.3.2.3.3.3三通道独立并行架构（RGB 分离处理）

图2.3.2.3.3.3 并行架构相关代码

isp_gamma 模块设计了 RGB 三通道独立并行架构，工作时三通道同步接收输入图像数据，并行执行 RAM 查找与矫正运算，无通道间时序等待，避免了串行处理导致的延迟累积，能够高效适配 1280x720 分辨率以内的实时图像处理需求，同时支持白平衡校准与 gamma 矫正一体化实现，灵活适配不同显示设备的色彩特性。

##### 2.3.2.3.4 defog 去雾模块

###### 2.3.2.3.4.1 基本原理

去雾模块使用暗通道先验算法作为去雾算法。该算法基于自然图像在局部区域内存在像素点其某一颜色通道值极低的统计规律，利用这一先验信息估计大气光强度与透射率分布，进而反演无雾图像的辐射值。

图2.3.2.3.4.1 去雾效果示意图

左：无雾图像及其对应的暗通道；右：有雾图像及其对应的暗通道

在计算机视觉领域，大气散射模型表示如下：

其中_I(x）_表示观测到的有雾图像，_J(x)_为待恢复的无雾图像，_A_为大气光强度，_t(x)_是透射率函数，反映光线穿透雾霾的比例。

暗通道先验法是 He 等人在统计大量无雾图像中提出一个先验定理：在无雾图像的大部分局部区域内，存在一些像素点，在至少一个颜色通道中具有很低的像素值。因此暗通道的模型表示如下：

，则大气散射模型可以表示如下：

假设区域内的透射率是常数，记作，则对上式计算暗通道得：

根据暗通道先验， 趋于 0，因此可以得到：

联立上面两个式子，可得到透射率的计算公式：

通过透射率、大气光强和有雾图像可得到无雾图像：

其中，为透射率的下界，防止透射率接近0时，失去原图信息。

由于去雾后图像的亮度偏低，需要对图像的亮度进行调整。He等人根据去雾后图像的灰度值大小对图像的亮度进行调整，首先计算灰度值：

其中，、、为RGB通道的像素值，为当前像素点的灰度值。亮度调整公式如下：

其中，_c_为RGB三个颜色通道， _p_为亮度系数， _p_越大，图像的亮度越高。2.3.2.3.4.2 硬件实现

2.3.2.3.4.2.1 defog_top顶层模块

图2.3.2.3.4.2.1 defog模块架构示意图

Defog_top顶层模块负责整个defog系统的集成和协调。模块输入为24位RGB原始图像，输出为去雾后的YUV图像，通过uart串口调控tx_min的值可实现去雾强度的连续可调。模块中，Y通道增强可通过uart串口控制其开关和调节其强度。

2.3.2.3.4.2.2 dark_channel（暗通道计算模块）

Dark_channel模块基于暗通道先验理论，物理意义明确，将彩色RGB图像转换为单通道暗通道图，量化每个像素区域的雾浓度，为后续透射率估计和去雾恢复奠定基础。

图2.3.2.3.4.2.2(1) 暗通道计算模块流程图

图2.3.2.3.4.2.2(2) Stage3排序树示意图

2.3.2.3.4.2.3 calculate_A（大气光值估计模块）

大气光值估计模块的功能是从输入的RGB图像数据中估算大气值 A_value，通过对整个图像帧分析，找出最亮像素的亮度值作为大气光估计值。

图2.3.2.3.4.2.3(1) 大气光值估计模块流程图

图2.3.2.3.4.2.3(2) RGB三通道最大值提取两级比较树代码

Calculate_A模块需要3个比较器，1个寄存器，简化版的实现能在保持计算效果的同时节省资源；同时A值每帧更新1次，保证帧内的稳定。

2.3.2.3.4.2.4 tx_get（透射率计算模块）

透射率计算模块的功能是对输入图像进行去雾处理中的透射率计算和调整。

基于暗通道先验理论，透射率计算公式为：

其中，与基本原理中略有差别的是，此公式引入保留系数，取值0.95，避免天空区域过度去雾。

考虑到FPGA不擅长浮点数运算，本模块硬件实现的公式为：

详细实现步骤如下：

图2.3.2.3.4.2.4(1) 透射率计算模块流程图

图2.3.2.3.4.2.4(2) Stage1移位优化代码

Stage3倒数查找表中，为了利于硬件实现，存储的是，即左移16位，后续得到乘积结果后，再将结果右移16位，以得到正确结果。

图2.3.2.3.4.2.4(3) Stage3 16段查找表代码

2.3.2.3.4.2.5 time_alignment（多路数据时序对齐模块）

Time_alignment模块主要有两大功能：

功能 1：延迟对齐。通过移位寄存器链延迟 RGB 图像 9 clk，与透射率图同步。

图2.3.2.3.4.2.5 移位逻辑代码实现

功能 2：数据汇聚。将分散的数据流（RGB、透射率图、大气光值）汇聚到一个模块输出，简化后级连接。

2.3.2.3.4.2.6 haze_removal_cal（去雾恢复计算核心模块）

Haze_removal_cal是去雾算法的核心恢复计算模块，负责根据透射率图和大气光值，从有雾图像中恢复出清晰图像。其端口连接图如下：

图2.3.2.3.4.2.6(1) haze_removal_cal模块输入输出端口示意图

理论上，通过透射率、大气光强和有雾图像可得到无雾图像：

其中，为透射率的下界，防止透射率接近0时，失去原图信息。

实际实现时，由tx_min实现，tx_min为用户通过uart串口设置的去雾强度对应的tx和与大气光值相关的场景自适应保护机制所限制的tx中的较大值。

Haze_removal_cal的核心模块如下：

图2.3.2.3.4.2.6(2) Haze_removal_cal模块流程图

Stage3去雾公式计算模块具体如下：

图2.3.2.3.4.2.6(3) 去雾公式计算模块流程图

Stage2倒数查找表中，为了利于硬件实现，存储的是，即左移16位，后续得到乘积结果后，再将结果右移16位，以得到正确结果。

图2.3.2.3.4.2.6(4) Stage2 16段查找表代码

###### 2.3.2.3.4.3 仿真

defog模块仿真的图片结果如下：

图2.3.2.3.4.3(1) 输入原始图像

图2.3.2.3.4.3(2) 输出去雾图像

输出去雾图像后续经过Y通道增强后，可生成较为准确的去雾图。

#### 2.3.2.4 YUV域处理模块

##### 2.3.2.4.1 CLAHE自适应限制对比度直方图均衡

###### 2.3.2.4.1.1 基本原理

图2.3.2.4.1.1 CLAHE算法基本原理示意图

CLAHE（Contrast Limited Adaptive Histogram Equalization，即对比度受限的自适应直方图均衡）是一种强大的图像增强算法，旨在改善图像的局部对比度，同时有效抑制噪声放大。

该算法是对传统自适应直方图均衡（AHE）的改进。AHE通过将图像划分为多个子区域（称为“Tiles”），并对每个Tile独立进行直方图均衡化，从而适应图像的局部特性。然而，AHE在噪声较大的平坦区域（如天空、墙面）时，容易过度放大噪声，产生伪影。

CLAHE通过引入“对比度限制”机制来解决此问题。其核心原理步骤如下：

1.图像分块 (Tiling)： 首先将整幅图像划分为M x N个连续且不重叠的矩形子区域（Tiles）。

2.直方图计算 (Histogram Calculation)：为每个Tile独立计算其灰度直方图，其中是灰度级（例如0-255）。

3.对比度限制 (Contrast Limiting / Clipping)：这是CLAHE的关键。首先，设定一个“裁剪阈值”（Clip Limit）。这个阈值 通常根据归一化的“裁剪因子”(Clip Factor, > ) 和该Tile的总像素数 以及灰度级数(例如256) 来计算：

然后，遍历该Tile的直方图，将超出此阈值的像素数“裁剪”掉：

4.溢出重分配 (Redistribution)： 将所有灰度级裁剪下来的像素总数（溢出量 ）收集起来：

然后，将这个溢出量均匀地重新分配到该Tile的个灰度级中，确保直方图的总像素数保持不变。每个灰度级分配到的平均增量为。重分配后的直方图为：

（注：为保证的总和仍为且，实际算法可能涉及更复杂的迭代重分配，但在硬件中常简化为单次平均分配）。

5.生成映射函数 (Mapping Function)： 基于裁剪并重分配后的直方图，计算每个Tile的累积分布函数（CDF）。这个CDF即为该Tile中心的灰度映射查找表（LUT）。

为了将其用作映射函数，需进行归一化（映射到0至L-1范围）：

6.双线性插值 (Bilinear Interpolation)： 为了消除Tile与Tile之间的边界“块效应”，图像中任何一个像素点的最终输出值，都不是直接由其所在Tile的LUT决定的。而是根据该像素点的位置，查找其周围最近的四个Tile中心（左上TL, 右上TR, 左下BL, 右下BR）的LUT映射值，再通过双线性插值算法计算得出加权平均值。

假设像素P在Tile内的相对坐标为（已归一化到0-1范围），输入灰度值为，则：

这样，输出像素平滑地融合了周围四个Tile的对比度增强特性。

###### 2.3.2.4.1.2 硬件实现

2.3.2.4.1.2.1 clahe_top顶层模块

图2.3.2.4.1.2.1(1) CLAHE算法模块架构图

顶层模块负责整个CLAHE系统的集成和协调，管理各子模块间的数据流和控制流，实现乒乓控制逻辑。

在CDF计算完成时切换ping_pong_flag，充分利用帧间隙时间，确保下一帧vsync上升沿来临前，乒乓切换已完成。

图2.3.2.4.1.2.1(2) 乒乓切换关键代码

2.3.2.4.1.2.2 clahe_coord_counter（坐标计数器模块）

实时计算输入像素的全局坐标、所属tile索引和tile内相对坐标，为直方图统计和像素映射提供位置信息。

在href有效期间递增横向坐标x_cnt，行结束时递增纵向坐标y_cnt，帧无效期间复位所有计数器。对于块tile的索引计算，使用比较器链代替除法器（节省资源）。

横向索引：tile_x = f(x_cnt / 320)；纵向索引：tile_y = f(y_cnt / 180)；

总索引：tile_idx = {tile_y, tile_x}（4bit）。

其中块内坐标的计算，使用移位加法计算，减少资源使用。

local_x = x_cnt - tile_x \* 320，local_y = y_cnt - tile_y \* 180，

乘法用移位替代：

tile_x \* 320 = (tile_x << 8) + (tile_x << 6)，

tile_y \* 180 = (tile_y << 7) + (tile_y << 5) + (tile_y << 4) + (tile_y << 2)。

图2.3.2.4.1.2.2 块坐标计算关键代码

2.3.2.4.1.2.3 clahe_histogram_stat（直方图统计模块）

图2.3.2.4.1.2.3(1) 直方图统计模块流水线流程图

对每个tile的256个灰度级进行实时统计，使用3级流水线实现读-增-写操作。

对于这种流水读写ram情况，极易出现读写冲突情况（读写同一地址），经分析存在以下冲突情况：

1：连续相同像素值

例如像素序列：100, 100, 50，对于第二个100像素，读取统计旧值时，第一个100的累加值暂未写入，导致第二个像素累加值会发生错误。

2：间隔相同像素值（流水线深度冲突）

例如像素序列：100, 50, 100...（间隔2周期，< 流水线深度3）

第二个100像素值读入所在周期，其读地址产生，同时第一个100在该周期写入累加值，故发生读写冲突。

对于问题1，检测连续输入的相同像素值，合并为一次RAM写入，确保统计值正确的同时大幅减少RAM访问次数。

图2.3.2.4.1.2.3(2) 像素连续相同处理关键代码 条件判断

如果出现相邻相等的情况，那么此时统计值自增二，来补偿读到的旧值带来的误差

图2.3.2.4.1.2.3(3) 像素连续相同处理关键代码 增量修改

对于问题2，其实可以使用真双端口RAM并配置为写优先模式来解决读写冲突问题，但是为了减少资源占用，部署更多算法，这里仍采用伪双端口ram，通过旁路逻辑解决读写冲突。若当前周期发生写地址与读地址相同，那么寄存当前写数据，作为本周期正在读的像素的读取值，不再使用从ram读取到的未更新的旧数据。下附关键代码，具体流程可参考流程图。

图2.3.2.4.1.2.3(4) 像素间隔相同处理关键代码

2.3.2.4.1.2.4 clahe_clipper_cdf（对比度限制与CDF计算模块）

该模块在histogram结束后，对每帧图像16个tile的直方图数据进行Clip阈值限制裁剪和CDF计算，最后归一化生成像素映射查找表。使用的有限状态机流程如下。

图2.3.2.4.1.2.4 clahe_clipper_cdf模块状态机流程图

表2.3.2.4.1.2.4 clahe_clipper_cdf模块不同状态消耗周期统计表

|     |     |     |
| --- | --- | --- |
| 状态  | 周期数 | 说明  |
| READ_HIST_CLIP | 257 | 读取+裁剪 |
| CLIP_REDIST | 257 | 仅在有溢出时执行 |
| CALC_CDF | 257 | 累积分布函数计算 |
| WRITE_LUT | 259 | 3级流水线归一化写入 |
| NEXT_TILE | 1   | tile切换 |
| DONE | 1   | 产生cdf_done脉冲 |

分析该流程在每帧中的耗时，由上表可知，每块tile总周期数约257+257+257+259+1+1=1032周期，16块耗时约16\*1032=16512周期，在96MHz时钟频率下耗时约172μs， 1280×720@30fps帧间隙约33ms，所以cdf模块的处理时间充足。同时，cdf模块在histogram统计结束后立即开始，充分利用帧间隙时间，提升性能。

2.3.2.4.1.2.5 clahe_ram_16tiles_parallel（RAM管理模块）

图2.3.2.4.1.2.5(1) clahe_clipper_cdf模块使用的RAM架构图

clahe_ram_16tiles_parallel模块负责管理32块伪双端口RAM，实现乒乓操作、四块并行读取和多端口仲裁。上图仅展示A组16块的主要架构，B组架构相同，通过乒乓操作进行切换。

cdf计算模块和histogram模块同一时刻只需一组读写端口，所以为了尽可能减少资源利用，使用伪双端口ram。同时由于mapping模块进行双线性插值时需要并行读取四个块（tile）的计算结果，所以每一分块都需要分配一块ram，共需16块ram。为了避免统计写入和映射模块读出冲突，我们设计使用乒乓双组RAM架构，架构如下：

帧N（ping_pong_flag=0）：

\- RAM_A组：用于统计（Port A写，Port B读）

\- RAM_B组：用于映射（Port B四块并行只读）

帧N+1（ping_pong_flag=1）：

\- RAM_B组：用于统计（Port A写，Port B读）

\- RAM_A组：用于映射（Port B四块并行只读）

模块接口如下图所示，cdf模块与histogram模块同一时刻只需读取单一地址数据，故与cdf计算模块、hist直方图统计模块的连接分别引出一组读写端口，内部进行仲裁复用。由于mapping模块中的双线性插值需要读取当前像素最近的四个块（tile）的输出LUT，为了实现mapping模块的全流水，实现了四个块的并行读取，引出mapping模块需要使用的四个读数据端口和读地址端口，由mapping模块计算得到四个块的坐标输入，进行地址译码，同时输出四个块的读取数据。

图2.3.2.4.1.2.5(2) clahe_clipper_cdf模块输入输出端口示意图

###### **2.3.2.4.1.3 仿真及上板综合**

鉴于图像区域每个分块都需要分配一块BRAM，为减少资源占用，故本工程采用4×4=16分块设计，虽然实际输出效果远不如8×8tile，但效果优于传统的HE算法。

modelsim仿真波形及图片结果如下：

受限于硬件实现的除法精度问题，输出图像不可避免地保留有较明显的分块效应，但该块边界可通过在YUV域进行双边滤波减轻。

仿真通过进行上板验证过程中，发现上板CLAHE模块输出的Y值始终为0，仿真结果始终没问题，百思不得其解。经过进一步分析易灵思综合生成的网表map.v文件，我们怀疑易灵思efinity的综合优化算法或存在bug！对于相似逻辑操作路径存在错误合并！具体错误原因及RTL层面的尝试我们已放于文末，截至本文提交前暂未能从RTL层面规避。我们在易灵思交流群中尝试寻求奥唯思的帮助，未能有效解决，联系易灵思的技术支持暂未得到回复。虽然我们很遗憾未能将辛苦探索钻研出的RTL层算法实际上板验证，但我们希望我们恰巧遇到的该综合问题能得到易灵思的重视，一起助力国产FPGA的发展与壮大。

##### 2.3.2.4.2 2DNR 2D降噪

###### 2.3.2.4.2.1 基本原理

该模块基于双边滤波器，使用双边滤波的方法。传统均值滤波的方法中，所有邻域像素权重相同，这会在一定程度上带来边缘模糊的问题。而双边滤波的方法结合了灰度相似性权重和空间距离权重，从而在一定程度上保护边缘的同时实现良好的降噪效果。

该模块的核心功能是对Y通道进行9×9自适应加权平均降噪，UV通道延迟对齐输出。

公式：

其中，为滤波后的结果；为归一化因子；为空间距离的权重；为相似度权重；为中心像素点亮度值；为邻域像素点的亮度值；为邻域的大小；为中心像素点与邻域像素点之间的距离；为空间域核；为像素域核。

空间域核为二维高斯函数，像素域核为衡量像素变化的程度。在图像的非边缘区域，像素值变化小，空间距离权重起主要作用，等效于高斯滤波；在图像的边缘区域，像素值变化大，相似度权重起主要作用，保持图像的边缘信息。

空间距离权重和相似度权重的计算公式为：

其中，和为预设的权重值，与为中心像素点和邻域像素点的坐标。

###### 2.3.2.4.2.2 硬件实现

2.3.2.4.2.2.1 isp_2dnr_top顶层模块

图2.3.2.4.2.2.1(1) 2DNR模块算法架构图

顶层模块负责整个2DNR系统的控制与集成，连接接口并定义输出选择与输出混合策略。通过原始图像与降噪结果的混合，实现分档模式与连续可调模式两种降噪模式。

分档模式利用移位操作，避免了乘法器的引入，实现了OFF（0%降噪）、LOW（25%降噪）、MID（50%降噪）、HIGH（93.75%降噪）四个档位，便于实际使用时根据场景快速切换。

连续可调模式公式原理如下：

output = (原始 × (255-强度) + 降噪 × 强度) ÷ 255

实际编码时，利用乘法与移位操作，避免耗时的除法运算：

数学原理：1/255 ≈ 257/65536

图2.3.2.4.2.2.1(2) 连续可调模式实现

2.3.2.4.2.2.2 2dnr_params_gen（参数生成模块）

参数生成模块是一个查找表(LUT)管理器,根据用户选择的降噪档位, 为后续的降噪核心模块(isp_2dnr)提供一整套精心调校的参数。

模块内部定义了4套（分别对应OFF、LOW、MID、HIGH四个档位）完整的参数表,每套包含15组(diff_value, weight)参数对。

当降噪核心（isp_2dnr）处理一个像素时，它会：

1.计算该像素与周围邻域像素的差值(diff)；

2.在15组参数中查找这个diff落在哪个区间；

3.使用对应的权重(weight)来决定降噪强度。

该模块的整体逻辑是：像素差值越小 → 越可能是噪点 → 权重越大 → 降噪越强；像素差值越大 → 越可能是真实边缘 → 权重越小 → 保护不处理。

该模块可实现：

1.预设档位模式：提供4个精心调校的降噪挡位(OFF/LOW/MID/HIGH);

2.即时切换：通过2位控制信号(level\[1:0\])实现单周期挡位切换；

3.零计算开销：预先定义好所有参数，无需实时计算。

以MID档位举例：

图2.3.2.4.2.2.2 MID档位参数表

MID档位实现中等阈值范围: diff阈值达到190,覆盖更多像素；通过阈值的设置达到降噪上的平衡取舍: 既处理噪点, 又适度平滑边缘。

时序上，参数切换在一个时钟周期内完成, 下一帧图像立即使用新参数。

该模块输出的diff_value和weight是打包向量, 格式如下:

diff_value\[119:0\] = {diff\[14\], diff\[13\], ..., diff\[1\], diff\[0\]}

↑最高位 ↑最低位

(第14组参数) (第0组参数)

weight\[74:0\] = {weight\[14\], weight\[13\], ..., weight\[1\], weight\[0\]}

↑最高位 ↑最低位

(第14组参数) (第0组参数)

后续的isp_2dnr核心模块会解包这些数据, 提取每一组参数进行降噪计算。

2.3.2.4.2.2.3 isp_2dnr（二维降噪模块）

图2.3.2.4.2.2.3 二维降噪模块流水线流程图

关键特性：

1.  除零保护：当所有权重都为0时（极端边缘场景），直接输出中心像素。

2\. UV通道处理：UV通道只做延迟对齐，不降噪。原因是：UV通道分辨率通常是Y通道的一半（色度子采样），降噪主要针对亮度（Y），色度平滑度要求较低，在降噪效果和硬件资源使用上取得平衡。

3\. 资源消耗：对内存的需求主要是行缓存。

4\. 降噪强度控制：diff_value 和 weight 数组通过2dnr_params_gen模块提供，支持4档强度；

5\. 高斯空间权重矩阵：用移位代替乘法，零DSP消耗。通过预设的移位系数模拟高斯分布权重，硬件实现无需DSP资源。

##### 2.3.2.4.3 sharpen 锐化

###### 2.3.2.4.3.1 基本原理

该模块使用Unsharp Masking算法，其基本公式为：

_Sharpen = Original + (Original - Blurred) × Amount_

其中_Original_为原始图像，_Blurred_为经过高斯模糊处理后的图像，_(Original-Blurred)_得到图像的高频细节，_Amount_控制锐化强度。通过增强边缘对比度，使图像细节更加清晰。

Unsharp Masking算法的一般流程为：

1.  对原始图像进行高斯模糊，生成_Blurred_图像；
2.  将_Original_与_Blurred_相减，得到高频边缘信息；
3.  强度调节，将高频边缘信息乘以_Amount_系数，控制锐化程度；
4.  将调节后的高频信息叠加回原始图像；
5.  裁剪到有效范围，防止溢出。

Unsharp Masking算法的关键参数为：

1.  模糊半径：高斯核的标准差,控制模糊范围。

上式中，即为模糊半径。

1.  锐化强度：高频细节的放大倍数。上述_Amount_即为锐化强度。
2.  阈值：通过阈值的合理设置，选择参与锐化的像素，避免放大噪声。

###### 2.3.2.4.3.2 硬件实现

图2.3.2.4.3.2(1) Sharpen模块输入输出端口示意图

其中，gaussian_kernel_1d\[179:0\]为一维高斯核权重，sharpen_strength\[11:0\]为锐化强度系数。

在硬件实现中，采用可分离卷积将 9×9 二维高斯卷积分解为两个一维卷积，维持锐化效果的同时减少DSP资源的使用量。

图2.3.2.4.3.2(2) 一维高斯核解析代码实现

在sharpen模块中，通过uart串口发送sharpen_strength数据的方式，实现了锐化强度的连续可调。Sharpen模块的硬件实现流程图如下：

图2.3.2.4.3.2(3) sharpen模块流水线流程图

Sharpen模块的关键设计要点为：

1.  可分离卷积的实现，使计算量与DSP的用量大大减少，同时保持锐化的效果；
2.  中心像素延迟对齐，与经过模糊的图像相减得到高频细节；
3.  U/V通道只经过行缓存，不参与卷积；
4.  实现了sharpen强度的连续可调。

# **第三部分 完成情况及性能参数**

## **3.3 特性成果**

### **3.3.1 720P@60fps显示输出**

### **3.3.2 ISP效果**

ISP关闭拍摄手部皮肤，色彩暗淡，色调偏绿：

ISP关闭拍摄手部皮肤，色彩贴近肤色：

### 3.3.3 ISP延时

ISP所有模块均采用全流水设计，每周期像素吞吐量为1，故ISP部分延时即为所有模块处理流水线级数之和。每个模块的流水线级数整理为下表，在96MHz时钟频率下，**延时约1.02微秒，实时性极高**。

表3.3.3 每个模块的流水线级数表

| 模块  | 流水线级数 | 累计延迟 |
| --- | --- | --- |
| DPC | 10  | 10  |
| BNR | 7   | 17  |
| Bayer2RGB | 5   | 22  |
| DEFOG | 16  | 38  |
| RGB2YUV | 3   | 41  |
| 2DNR | 28  | 69  |
| Sharpen | 13  | 82  |
| CLAHE | 5   | 87  |
| YUV2RGB | 3   | 90  |
| DGAIN | 2   | 92  |
| WB  | 1   | 93  |
| CCM | 3   | 96  |
| Gamma | 2   | 98  |

### 3.3.4 ISP资源使用情况

表3.3.4 ISP资源使用情况

|     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- |
| 模块名称 | FFs | SRLs | ADDs | LUTs | RAMs | DSP |
| **XYCrop** (图像裁剪) | 35  | 0   | 23  | 32  | 0   | 0   |
| DPC (坏点校正) | 564 | 2   | 90  | 592 | 8   | 0   |
| **BNR** (双边降噪) | 435 | 2   | 552 | 93  | 8   | 0   |
| **DGAIN** (数字增益) | 14  | 0   | 0   | 58  | 0   | 1   |
| **AWB** (白平衡统计) | 590 | 0   | 217 | 628 | 2   | 0   |
| **AWB Smoother** (平滑) | 74  | 0   | 130 | 40  | 0   | 0   |
| **WB** (白平衡应用) | 29  | 0   | 0   | 40  | 0   | 2   |
| **Bayer2RGB** (去马赛克) | 254 | 1   | 139 | 200 | 4   | 0   |
| **CCM** (色彩校正) | 33  | 0   | 0   | 33  | 0   | 9   |
| **AE** (自动曝光) | 1575 | 0   | 440 | 1857 | 0   | 12  |
| **DGAIN Update** (增益更新) | 21  | 0   | 14  | 39  | 0   | 0   |
| **Gamma** (伽马校正) | 28  | 0   | 0   | 0   | 3   | 0   |
| **Defog** (去雾) | 3386 | 225 | 3329 | 3631 | 4   | 14  |
| **RGB2YUV** (色彩转换) | 51  | 0   | 68  | 1   | 0   | 7   |
| **2DNR** (2D降噪) | 3981 | 194 | 3130 | 9514 | 32  | 88  |
| **Sharpen** (锐化) | 1328 | 3960 | 2269 | 138 | 0   | 29  |
| **CLAHE** (自适应均衡) | 2083 | 109 | 1273 | 5149 | 35  | 9   |
| **YUV2RGB** (色彩转换) | 61  | 1   | 69  | 107 | 0   | 5   |
| **ISP总计** | ~14500 | ~4500 | ~12000 | ~22000 | ~96 | ~177 |

# **第四部分 总结**

4

5

- 1.  **可扩展之处**

AE、AWB的抖动问题需要进一步调节，灵敏度和稳定度需要协调；ISP部分可加入更多处理模块，且模块的资源使用和性能可进一步优化；CCM模块的色彩准确程度可以通过采集更大量的数据进行进一步校准。

- 1.  **心得体会**

作为FPGA嵌入式系统设计的初学者，我们在本项目的开发中遇到了许多煎熬和困难，也收获了许多宝贵经验，从verilog语法、modelsim仿真的使用、efinity软件的使用、算法的原理、架构和rtl细节设计，我们一步步不断探索、攻坚克难。在团队协作中，我们也学习git代码管理工具的使用，100余次的提交记录、多次的合并和变基，记录了我们的脚印，让我们逐步熟练使用git这项工具。

在这一过程中，我们遇到的最煎熬的bug就是CLAHE模块modelsim仿真通过，上板输出一直为0的问题，反复检查RTL百思不得其解，恍然间想到检查综合生成的网表，确实发现了问题：网表的数据路径与RTL行为严重不符！经过多次RTL级别的修改尝试，始终未能解决网表错误问题，最终我们将问题定位在efinity综合工具对于相似逻辑信号路径的合并优化怀疑该综合算法存在bug，正积极和efinity工程师沟通定位问题。虽最终没能上板呈现效果，但这一过程让我们对RTL级设计、仿真的使用、综合工具的行为这些FPGA开发流程有了更深刻的理解，debug就是不断蜕变的过程！

在此也感谢组委会提供的宝贵参赛机会，易灵思、奥唯思工程师老师们的技术支持！

# **第五部分 参考文献**

\[1\]王凌远,甄国涌,储成群,等. 基于ZYNQ的内窥镜图像处理系统设计\[J\]. 舰船电子工程,2024,44(7):108-112. DOI:10.3969/j.issn.1672-9730.2024.07.023.

\[2\]Kaiming He, Jian Sun and Xiaoou Tang, "Single image haze removal using dark channel prior," 2009 IEEE Conference on Computer Vision and Pattern Recognition, Miami, FL, USA, 2009, pp. 1956-1963, doi: 10.1109/CVPR.2009.5206515.

## 附件 efinity综合错误问题和调试历史

clahe_mapping_parallel.v中使用assign直接由计算出的当前像素最近的四个tile的索引生成读取cdf计算结果的tile地址，检查网表发现逻辑类似的四个路径被错误连接。

随后改为时序逻辑，使用流水线寄存器：

综合后发现CLAHE_top中信号连接出现错误，问题仍然是综合器对于逻辑相似的四个路径进行了错误合并：

随后尝试在CLAHE_top中也添加流水线寄存器：

综合结果寄存器也被错误连接：

为了避免寄存器被合并，我们尝试了独立always块写法，加虚拟逻辑，期望综合器能加以区分：

结果虚拟逻辑被生成，但主寄存器仍被合并。尝试用不同复位值区分，也仍然失败：

怀疑综合器可能进行了向量级别的优化，我们又尝试了将寄存器拆分为独立的1bit寄存器：

综合结果不同组信号的位之间出现了错误连接：

因为mapping模块的tile地址输出直连至ram控制模块，我们也尝试在ram模块的输入端口插入寄存器隔离，但由于综合结果mapping部分连接仍然错误，仍未能解决。

综上，RTL层面进行了多次的时序逻辑修改，综合器仍然进行了错误合并，我们怀疑是efinity的bug所致，导致我们的算法无法上板演示。我们可以提供整套源码便于易灵思定位问题。